<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥æœŸè³‡è¨Šè™•ç†å·¥å…· (æ•´åˆè‡ªå‹•è¤‡è£½èˆ‡é€²éšç¯©é¸)</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; }
        h1 { color: #0056b3; }
        h2 { border-bottom: 2px solid #ccc; padding-bottom: 5px; }
        .function-section { margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .output-area { background-color: #f4f4f4; border: 1px solid #aaa; padding: 10px; margin-top: 10px; white-space: pre-wrap; word-wrap: break-word; min-height: 50px; }
        .debug-area { background-color: #ffe; border: 1px dashed #c90; padding: 10px; margin-top: 10px; white-space: pre-wrap; font-size: 0.9em; max-height: 200px; overflow-y: auto; }
        button { padding: 10px 15px; margin-right: 10px; cursor: pointer; border: none; border-radius: 4px; background-color: #007bff; color: white; transition: background-color 0.3s; }
        button:hover { background-color: #0056b3; }
        input[type="text"], textarea, input[type="date"], select { width: 98%; padding: 8px; margin-top: 5px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        label { display: block; font-weight: bold; margin-top: 10px; }
        .input-group { margin-bottom: 15px; padding: 10px; border: 1px dotted #ccc; }
        .date-list { margin-top: 10px; padding-left: 20px; }
        .error-message { color: red; font-weight: bold; margin-top: 5px; }
        .range-generator { border: 2px solid #007bff; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        .range-generator h4 { margin-top: 0; color: #007bff; }
        .weekday-controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; padding: 5px 0;}
        .weekday-controls label { font-weight: normal; margin-right: 5px; display: inline-flex; align-items: center;}
        #copyStatus { padding: 8px; border-radius: 4px; margin-top: 10px; background-color: #f0f0f0; color: #333; }
        
        /* æ–°å¢ï¼šå¯é¸å–åˆ—è¡¨æ¨£å¼ */
        #selectableDateList {
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #fff;
        }
        .date-item-row {
            padding: 5px 0;
            border-bottom: 1px dotted #eee;
            display: flex;
            align-items: center;
        }
        .date-item-row:last-child {
            border-bottom: none;
        }
        .date-item-row input[type="checkbox"] {
            margin-right: 10px;
            width: auto;
        }
        .date-item-row span {
            flex-grow: 1;
        }
        .header-button {
            background-color: #28a745; /* ç¶ è‰² */
        }
        .header-button:hover {
            background-color: #1e7e34;
        }
    </style>
</head>
<body>

    <h1>ğŸ“… æ—¥æœŸè³‡è¨Šè™•ç†å·¥å…· (æ•´åˆè‡ªå‹•è¤‡è£½èˆ‡é€²éšç¯©é¸)</h1>

    <div class="function-section">
        <h2>ä¸»é¸å–®</h2>
        <button onclick="showSection('dateInputSection')">1. è¼¸å…¥æ—¥æœŸèˆ‡åˆ†é¡ (DATE_1)</button>
        </div>

    <div id="dateInputSection" class="function-section" style="display:block;">
        <h2>1. è¼¸å…¥æ—¥æœŸèˆ‡åˆ†é¡ (DATE_1)</h2>

        <div id="dataItemInput" class="input-group">
            <h3>è¼¸å…¥è³‡æ–™é …ç›®ä¸»é¡Œèˆ‡èªªæ˜</h3>
            <label for="inputSubject">ä¸»é¡Œ:</label>
            <input type="text" id="inputSubject" value="æœƒè­°">

            <label for="inputDescription">èªªæ˜(ç”¨æ–¼å¾ŒçºŒåˆ†é¡):</label>
            <input type="text" id="inputDescription" value="20251212æ‰¿è¾¦">
            
            <hr>

            <div class="range-generator">
                <h4>ğŸš€ æ‰¹é‡æ—¥æœŸç”¢ç”Ÿ (Date Range Generator)</h4>
                <label for="startDateRange">é–‹å§‹æ—¥æœŸ (YYYY/MM/DD):</label>
                <input type="text" id="startDateRange" placeholder="ä¾‹å¦‚: 2025/12/01" value="2025/12/01">

                <label for="endDateRange">çµæŸæ—¥æœŸ (YYYY/MM/DD):</label>
                <input type="text" id="endDateRange" placeholder="ä¾‹å¦‚: 2025/12/31" value="2025/12/31">
                
                <label style="margin-top: 15px;">æ’é™¤æ˜ŸæœŸå¹¾:</label>
                <div class="weekday-controls" id="weekdayControls">
                    </div>
                
                <label for="excludedDatesManual">æ’é™¤æŒ‡å®šæ—¥æœŸ (YYYY/MM/DDï¼Œé€—è™Ÿåˆ†éš”):</label>
                <input type="text" id="excludedDatesManual" placeholder="ä¾‹å¦‚: 2025/12/25, 2025/12/30">

                <label for="ampmRange">æ™‚æ®µé¸æ“‡ (AM/PM/AM/PM):</label>
                <select id="ampmRange">
                    <option value="am">ä¸Šåˆ (AM)</option>
                    <option value="pm">ä¸‹åˆ (PM)</option>
                    <option value="am/pm">å…¨å¤© (AM/PM)</option>
                </select>

                <button onclick="generateAndAddDates()">ç”¢ç”Ÿä¸¦åŠ å…¥æ—¥æœŸåˆ—è¡¨</button>
                <div id="rangeStatus" class="error-message"></div>
            </div>

            <hr>

            <label for="inputDateAmpm">
                **æˆ–æ‰‹å‹•è¼¸å…¥å¤šè¡Œæ—¥æœŸèˆ‡ä¸Šä¸‹åˆ (æ¯è¡Œä¸€å€‹ YYYY/MM/DD,AM/PM æ ¼å¼)**:
            </label>
            <textarea id="inputDateAmpm" rows="3" placeholder="ä¾‹å¦‚: 
2026/01/05,AM
2026/01/10,PM"></textarea>
            
            <button onclick="addMultipleDates()">æ‰‹å‹•è¼¸å…¥ä¸¦åŠ å…¥æ—¥æœŸ</button>
            
            <div id="dateInputStatus" class="error-message"></div>
            <div id="currentDatesDisplay" class="date-list"></div>
        </div>
        <div style="margin-top: 20px;">
            <button class="header-button" onclick="finishDataItem()">âœ… å®Œæˆæ­¤è³‡æ–™é …ç›®ä¸¦å„²å­˜</button>
            <button onclick="processAllDates()">ğŸ”„ é‡æ–°æ•´ç†æ‰€æœ‰å½™æ•´è³‡è¨Š</button>
        </div>
        
        <h3 style="margin-top: 30px;">ğŸ—“ï¸ æ‰€æœ‰è³‡æ–™å½™æ•´ (å¯å‹¾é¸ä»¥æ’é™¤)</h3>
        
        <div style="margin-bottom: 10px;">
            <button onclick="toggleAllCheckboxes(true)">å…¨é¸</button>
            <button onclick="toggleAllCheckboxes(false)">å…¨ä¸é¸</button>
        </div>

        <div id="selectableDateList">
            è«‹å…ˆå®Œæˆè³‡æ–™é …ç›®å„²å­˜ã€‚
        </div>

        <p id="copyStatus">CSV å…§å®¹å°‡æœƒè‡ªå‹•è¤‡è£½åˆ°å‰ªè²¼ç°¿ã€‚</p>

        <h3 style="margin-top: 30px;">â¬‡ï¸ æ­¥é©Ÿ 2: ç¯©é¸ä¸¦ç”Ÿæˆæœ€çµ‚åˆ†é¡çµæœ</h3>
        <button onclick="filterAndClassifyDates()">åŸ·è¡Œç¯©é¸èˆ‡åˆ†é¡</button>
        <button id="downloadClassificationButton" onclick="downloadClassificationCsv()" disabled>
            â¬‡ï¸ ä¸‹è¼‰åˆ†é¡çµæœ (YYYYMMDD-schedule.csv)
        </button>

        <h3>æ•´ç†å¾Œçš„è³‡æ–™ (ä¾èªªæ˜åˆ†çµ„èˆ‡æ—¥æœŸæ’åº)</h3>
        <pre class="output-area" id="classificationOutput">è«‹å…ˆåŸ·è¡Œç¯©é¸èˆ‡åˆ†é¡ã€‚</pre>
        
        <h3 style="margin-top: 30px;">åŸå§‹ Google Calendar CSV æ ¼å¼ (ä¾›é™¤éŒ¯èˆ‡æ‰‹å‹•è¤‡è£½)</h3>
        <pre class="output-area" id="csvOutput"></pre>
        
        <h3>é™¤éŒ¯è³‡è¨Š (å…¨åŸŸæ’åºå¾Œè³‡æ–™)</h3>
        <div class="debug-area" id="debugOutput"></div>
    </div>

    <div id="dateClassificationSection" style="display:none;"></div> 

    <script>
        // --- å…¨åŸŸè®Šæ•¸ ---
        let allDataItems = []; 
        let currentItemDates = []; 
        let lastClassificationCsvData = ''; 
        let currentFullCsvData = ''; // å„²å­˜ processAllDates ç”¢ç”Ÿçš„å®Œæ•´ CSV å…§å®¹
        
        // JS Date.getDay() å°æ‡‰ï¼š0=æ—¥, 1=ä¸€, 2=äºŒ, 3=ä¸‰, 4=å››, 5=äº”, 6=å…­
        const WEEKDAYS_ZH = ["æ—¥", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­"];

        // --- å·¥å…·å‡½æ•¸ (ä¿æŒä¸è®Š) ---

        function getFormattedDateForFilename() {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            const day = now.getDate().toString().padStart(2, '0');
            return `${year}${month}${day}`;
        }

        function convertToCsvSafeString(inputString) {
            if (inputString === null || inputString === undefined) {
                inputString = "";
            }
            inputString = String(inputString); 
            if (inputString.includes(',') || inputString.includes('"') || inputString.includes('\n')) {
                return `"${inputString.replace(/"/g, '""')}"`;
            }
            return inputString;
        }

        function parseDateAmpm(dateAmpmString) {
            const parts = dateAmpmString.split(',');
            const dateStr = parts[0].trim();
            const ampm = parts.length > 1 ? parts[1].trim().toLowerCase() : 'am';

            if (ampm !== 'am' && ampm !== 'pm' && ampm !== 'am/pm') {
                return { error: `ä¸Šä¸‹åˆè³‡è¨ŠéŒ¯èª¤: ${parts.length > 1 ? parts[1] : ''}ï¼Œè«‹ä½¿ç”¨ AM æˆ– PM æˆ– AM/PM` };
            }

            const dateParts = dateStr.split('/').map(p => parseInt(p, 10));
            if (dateParts.length !== 3 || dateParts.some(isNaN)) {
                 return { error: `æ—¥æœŸæ ¼å¼éŒ¯èª¤: ${dateStr}ï¼Œè«‹ä½¿ç”¨ YYYY/MM/DD` };
            }

            const year = dateParts[0];
            const month = dateParts[1] - 1; 
            const day = dateParts[2];
            
            let hour = 8; 
            const dateObj = new Date(year, month, day, hour, 0, 0);

            if (dateObj.getFullYear() !== year || dateObj.getMonth() !== month || dateObj.getDate() !== day) {
                return { error: `ç„¡æ•ˆçš„æ—¥æœŸ: ${dateStr}` };
            }
            
            if (ampm === 'pm') {
                dateObj.setHours(20); 
                hour = 20;
            } else if (ampm === 'am/pm') {
                dateObj.setHours(8); 
                hour = 8;
            }

            return { dateObj: dateObj, ampm: ampm, hour: hour };
        }

        function parseSimpleDate(dateStr) {
            const dateParts = dateStr.split('/').map(p => parseInt(p, 10));
            if (dateParts.length !== 3 || dateParts.some(isNaN)) {
                return null;
            }
            const year = dateParts[0];
            const month = dateParts[1] - 1; 
            const day = dateParts[2];

            const dateObj = new Date(year, month, day, 0, 0, 0); 
            
            if (dateObj.getFullYear() !== year || dateObj.getMonth() !== month || dateObj.getDate() !== day) {
                return null;
            }
            return dateObj;
        }
        
        function triggerDownload(csvContent, filename) {
            const bom = "\uFEFF"; 
            const blob = new Blob([bom + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
        
        async function copyToClipboard(text) {
            const statusElement = document.getElementById('copyStatus');
            statusElement.textContent = ""; 
            try {
                await navigator.clipboard.writeText(text);
                statusElement.textContent = "âœ… CSV å…§å®¹å·²è‡ªå‹•è¤‡è£½åˆ°å‰ªè²¼ç°¿ã€‚";
                statusElement.style.color = "green";
                statusElement.style.backgroundColor = "#e6ffe6";
                setTimeout(() => {
                    statusElement.textContent = "CSV å…§å®¹å°‡æœƒè‡ªå‹•è¤‡è£½åˆ°å‰ªè²¼ç°¿ã€‚";
                    statusElement.style.color = "#333";
                    statusElement.style.backgroundColor = "#f0f0f0";
                }, 5000); 
            } catch (err) {
                console.error('ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼ç°¿:', err);
                statusElement.textContent = "âŒ ç„¡æ³•è‡ªå‹•è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œè«‹æ‰‹å‹•è¤‡è£½ä¸‹æ–¹ [åŸå§‹ Google Calendar CSV æ ¼å¼] å…§å®¹ã€‚";
                statusElement.style.color = "red";
                statusElement.style.backgroundColor = "#fff0f0";
            }
        }

        // --- ä»‹é¢å’Œé‚è¼¯å‡½æ•¸ ---

        function generateWeekdayControls() {
            const container = document.getElementById('weekdayControls');
            container.innerHTML = ''; 

            WEEKDAYS_ZH.forEach((dayName, index) => {
                const label = document.createElement('label');
                const isWeekend = (index === 0 || index === 6); 
                
                label.innerHTML = `
                    <input type="checkbox" id="excludeDay${index}" data-day-index="${index}" ${isWeekend ? 'checked' : ''}>
                    æ’é™¤é€±${dayName}
                `;
                container.appendChild(label);
            });
        }
        
        function showSection(sectionId) {
            document.getElementById('dateInputSection').style.display = 'none';
            // ç”±æ–¼æ•´åˆï¼ŒdateClassificationSection éš±è—
            document.getElementById('dateClassificationSection').style.display = 'none';
            document.getElementById(sectionId).style.display = 'block';
            
            if (sectionId === 'dateInputSection') {
                currentItemDates = [];
                updateCurrentDatesDisplay();
                
                if (allDataItems.length === 0) {
                     document.getElementById('inputSubject').value = 'æœƒè­°';
                     document.getElementById('inputDescription').value = '20251212æ‰¿è¾¦';
                }
                
                document.getElementById('inputDateAmpm').value = '';
                document.getElementById('dateInputStatus').textContent = '';
                document.getElementById('rangeStatus').textContent = '';
                document.getElementById('downloadClassificationButton').disabled = true;
                document.getElementById('classificationOutput').textContent = 'è«‹å…ˆåŸ·è¡Œç¯©é¸èˆ‡åˆ†é¡ã€‚';
                processAllDates(); 
                generateWeekdayControls(); 
            } 
        }

        function updateCurrentDatesDisplay() {
            // (æ­¤å‡½å¼ä¿æŒä¸è®Š)
            const container = document.getElementById('currentDatesDisplay');
            container.innerHTML = '<h4>âœ… å·²åŠ å…¥çš„æ—¥æœŸ (æ­¤è³‡æ–™é …ç›®):</h4>'; 
            if (currentItemDates.length === 0) {
                container.innerHTML += '<p>ç„¡æ—¥æœŸè³‡è¨Š</p>';
                return;
            }

            const ul = document.createElement('ul');
            const sortedDates = [...currentItemDates].sort((a, b) => a.dateObj.getTime() - b.dateObj.getTime());

            sortedDates.forEach(item => {
                const li = document.createElement('li');
                const ampmText = item.ampm.toUpperCase();
                const dateStr = `${item.dateObj.getFullYear()}/${(item.dateObj.getMonth() + 1).toString().padStart(2, '0')}/${item.dateObj.getDate().toString().padStart(2, '0')}`;
                const timeStr = item.dateObj.toTimeString().substring(0, 5); 
                const dayIndex = item.dateObj.getDay(); 
                li.textContent = `${dateStr} (é€±${WEEKDAYS_ZH[dayIndex]}), ${ampmText} (${timeStr}) - ${item.subject}`;
                ul.appendChild(li);
            });
            container.appendChild(ul);
        }

        function generateAndAddDates() {
             // (æ­¤å‡½å¼ä¿æŒä¸è®Š)
            const startStr = document.getElementById('startDateRange').value.trim();
            const endStr = document.getElementById('endDateRange').value.trim();
            const excludedManualStr = document.getElementById('excludedDatesManual').value.trim();
            const ampmRange = document.getElementById('ampmRange').value;
            const statusElement = document.getElementById('rangeStatus');
            const subject = document.getElementById('inputSubject').value.trim();
            const description = document.getElementById('inputDescription').value.trim();
            statusElement.textContent = '';
            
            if (!subject || !description) {
                statusElement.textContent = "è«‹å…ˆè¼¸å…¥ä¸»é¡Œå’Œèªªæ˜ã€‚";
                return;
            }

            const startDate = parseSimpleDate(startStr);
            const endDate = parseSimpleDate(endStr);

            if (!startDate || !endDate) {
                statusElement.textContent = "é–‹å§‹æ—¥æœŸæˆ–çµæŸæ—¥æœŸæ ¼å¼éŒ¯èª¤ (éœ€ç‚º YYYY/MM/DD)ã€‚";
                return;
            }
            if (startDate > endDate) {
                statusElement.textContent = "é–‹å§‹æ—¥æœŸå¿…é ˆæ—©æ–¼æˆ–ç­‰æ–¼çµæŸæ—¥æœŸã€‚";
                return;
            }

            const excludedDays = new Set();
            for(let i = 0; i < 7; i++) {
                const checkbox = document.getElementById(`excludeDay${i}`);
                if (checkbox && checkbox.checked) {
                    excludedDays.add(i);
                }
            }

            const excludedDatesSet = new Set();
            if (excludedManualStr) {
                const manualDates = excludedManualStr.split(',').map(d => d.trim()).filter(d => d.length > 0);
                manualDates.forEach(dateStr => {
                    const dateObj = parseSimpleDate(dateStr);
                    if (dateObj) {
                        excludedDatesSet.add(dateObj.toISOString().substring(0, 10)); 
                    } else {
                        statusElement.textContent += `æ’é™¤æ—¥æœŸæ ¼å¼éŒ¯èª¤: ${dateStr} å·²å¿½ç•¥ã€‚\n`;
                    }
                });
            }

            let currentDate = new Date(startDate);
            let successCount = 0;

            while (currentDate <= endDate) {
                const currentISODate = currentDate.toISOString().substring(0, 10);
                const dayOfWeek = currentDate.getDay(); 
                let isExcluded = false;

                if (excludedDays.has(dayOfWeek)) {
                    isExcluded = true;
                }
                
                if (excludedDatesSet.has(currentISODate)) {
                    isExcluded = true;
                }

                if (!isExcluded) {
                    const dateStrForParse = `${currentDate.getFullYear()}/${currentDate.getMonth() + 1}/${currentDate.getDate()},${ampmRange}`;
                    const result = parseDateAmpm(dateStrForParse);

                    if (!result.error) {
                        const dateInfo = {
                            dateObj: result.dateObj,
                            ampm: ampmRange,
                            timeslotHour: result.hour,
                            subject: subject,
                            description: description
                        };
                        currentItemDates.push(dateInfo);
                        successCount++;
                    }
                }

                currentDate.setDate(currentDate.getDate() + 1);
            }

            updateCurrentDatesDisplay();
            statusElement.textContent = `æˆåŠŸç”¢ç”Ÿä¸¦åŠ å…¥äº† ${successCount} å€‹ç¬¦åˆæ¢ä»¶çš„æ—¥æœŸã€‚`;
        }

        function addMultipleDates() {
             // (æ­¤å‡½å¼ä¿æŒä¸è®Š)
            const input = document.getElementById('inputDateAmpm').value;
            const subject = document.getElementById('inputSubject').value.trim();
            const description = document.getElementById('inputDescription').value.trim();
            const statusElement = document.getElementById('dateInputStatus');
            statusElement.textContent = ''; 

            if (!subject || !description) {
                statusElement.textContent = "è«‹å…ˆè¼¸å…¥ä¸»é¡Œå’Œèªªæ˜ã€‚";
                return;
            }
            if (!input.trim()) {
                statusElement.textContent = "æ—¥æœŸè¼¸å…¥æ¡†ä¸å¯ç‚ºç©ºã€‚";
                return;
            }

            const inputLines = input.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let successCount = 0;
            let errorMessages = [];

            inputLines.forEach((line, index) => {
                const normalizedLine = line.includes(',') ? line : `${line},am`; 
                const result = parseDateAmpm(normalizedLine);

                if (result.error) {
                    errorMessages.push(`ç¬¬ ${index + 1} è¡Œ (${line}): ${result.error}`);
                    return;
                }

                const dateInfo = {
                    dateObj: result.dateObj,
                    ampm: result.ampm,
                    timeslotHour: result.hour,
                    subject: subject,
                    description: description
                };

                currentItemDates.push(dateInfo);
                successCount++;
            });

            updateCurrentDatesDisplay();
            
            if (errorMessages.length > 0) {
                statusElement.textContent = `æˆåŠŸåŠ å…¥ ${successCount} å€‹æ—¥æœŸã€‚ä»¥ä¸‹æ˜¯éŒ¯èª¤åˆ—è¡¨:\n${errorMessages.join('\n')}`;
            } else if (successCount > 0) {
                statusElement.textContent = `æˆåŠŸåŠ å…¥æ‰€æœ‰ ${successCount} å€‹æ—¥æœŸã€‚`;
            } else {
                 statusElement.textContent = `æ²’æœ‰æˆåŠŸçš„æ—¥æœŸè¼¸å…¥ã€‚`;
            }
            document.getElementById('inputDateAmpm').value = ''; 
        }
        
        /**
         * å®Œæˆç•¶å‰è³‡æ–™é …ç›®ï¼Œå„²å­˜åˆ° allDataItemsï¼Œä¸¦ç«‹å³æ›´æ–° CSV å½™æ•´çµæœã€‚
         */
        function finishDataItem() {
            const subject = document.getElementById('inputSubject').value.trim();
            const description = document.getElementById('inputDescription').value.trim();

            if (!subject || !description) {
                alert("ä¸»é¡Œæˆ–èªªæ˜ä¸å¯ç‚ºç©ºã€‚");
                return;
            }
            
            if (currentItemDates.length === 0) {
                 alert("è«‹å…ˆåŠ å…¥è‡³å°‘ä¸€å€‹æ—¥æœŸï¼Œå†å„²å­˜æ­¤è³‡æ–™é …ç›®ã€‚");
                 return;
            }


            // 1. å„²å­˜ç•¶å‰çš„è³‡æ–™é …ç›®
            allDataItems.push({
                subject: subject,
                description: description,
                dateInfo: [...currentItemDates] 
            });

            // 2. æ¸…ç†ç•¶å‰è¼¸å…¥å€åŸŸï¼Œæº–å‚™è¼¸å…¥ä¸‹ä¸€å€‹é …ç›®
            currentItemDates = [];
            document.getElementById('inputDateAmpm').value = '';
            updateCurrentDatesDisplay(); 
            document.getElementById('dateInputStatus').textContent = '';
            document.getElementById('rangeStatus').textContent = '';
            
            // 3. ç«‹å³å‘¼å« processAllDates() ä¾†æ›´æ–°å’Œé¡¯ç¤ºæ‰€æœ‰çš„å½™æ•´è³‡æ–™
            processAllDates(); 
            
            alert(`è³‡æ–™é …ç›®å·²å„²å­˜ (ç›®å‰å…±æœ‰ ${allDataItems.length} å€‹é …ç›®)ã€‚æ‰€æœ‰è³‡æ–™å½™æ•´è³‡è¨Šå·²æ›´æ–°ã€‚`);
        }

        /**
         * è™•ç†æ‰€æœ‰å·²å„²å­˜çš„æ—¥æœŸï¼Œç”Ÿæˆ CSVï¼Œå„²å­˜åˆ° currentFullCsvDataï¼Œä¸¦ç¹ªè£½å¯é¸åˆ—è¡¨ã€‚
         */
        function processAllDates() {
            
            if (allDataItems.length === 0) {
                document.getElementById('csvOutput').textContent = "æ²’æœ‰ä»»ä½•å·²å„²å­˜çš„è³‡æ–™é …ç›®ã€‚";
                document.getElementById('debugOutput').textContent = "æ²’æœ‰ä»»ä½•å·²å„²å­˜çš„è³‡æ–™é …ç›®ã€‚";
                document.getElementById('selectableDateList').innerHTML = 'ç„¡è³‡æ–™å¯é¸å–ã€‚';
                copyToClipboard(""); 
                return;
            }

            let globalDateInfoArray = [];
            allDataItems.forEach(dataItem => {
                globalDateInfoArray.push(...dataItem.dateInfo);
            });

            const sortedGlobalDateInfoArray = globalDateInfoArray.sort((a, b) => {
                return a.dateObj.getTime() - b.dateObj.getTime();
            });

            let debugOutput = "--- é™¤éŒ¯è³‡è¨Šï¼šå…¨åŸŸæ’åºå¾Œè³‡æ–™ ---\n";
            let csvOutput = "Start date,Subject,All Day Event,Description\n";
            const selectableListContainer = document.getElementById('selectableDateList');
            selectableListContainer.innerHTML = '';
            
            // ç¹ªè£½å¯é¸åˆ—è¡¨
            sortedGlobalDateInfoArray.forEach((info, index) => {
                const dateString = `${info.dateObj.getFullYear()}/${(info.dateObj.getMonth() + 1).toString().padStart(2, '0')}/${info.dateObj.getDate().toString().padStart(2, '0')}`;
                
                // æ±ºå®š CSV ä¸­çš„ä¸»é¡Œ (åŒ…å« AM/PM)
                const subjectForCsv = info.ampm.toUpperCase() ? `${info.ampm.toUpperCase()}-${info.subject}` : info.subject;

                // æº–å‚™ CSV è¡Œ
                const safeDate = convertToCsvSafeString(dateString);
                const safeSubject = convertToCsvSafeString(subjectForCsv);
                const safeDescription = convertToCsvSafeString(info.description);
                const safeAllDayEvent = convertToCsvSafeString("TRUE");
                
                const csvLine = `${safeDate},${safeSubject},${safeAllDayEvent},${safeDescription}`;
                csvOutput += csvLine + "\n";
                
                // æº–å‚™åˆ—è¡¨é¡¯ç¤º
                const displayTime = info.ampm.toUpperCase();
                const displaySubject = info.subject;
                const displayDescription = info.description;
                const displayFullText = `${dateString} (${displayTime}) - ${displaySubject} [${displayDescription}]`;

                const row = document.createElement('div');
                row.className = 'date-item-row';
                row.innerHTML = `
                    <input type="checkbox" id="dateCheck${index}" data-csv-line="${encodeURIComponent(csvLine)}" checked>
                    <label for="dateCheck${index}"><span>${displayFullText}</span></label>
                `;
                selectableListContainer.appendChild(row);

                debugOutput += `  æ—¥æœŸç‰©ä»¶: ${dateString} ${info.dateObj.toTimeString().substring(0, 8)}, ä¸Šä¸‹åˆ: ${info.ampm}, ä¸»é¡Œ: ${info.subject}, èªªæ˜: ${info.description}\n`;
            });
            
            document.getElementById('debugOutput').textContent = debugOutput;
            document.getElementById('csvOutput').textContent = csvOutput;
            currentFullCsvData = csvOutput; // å„²å­˜å®Œæ•´çš„ CSV ä¾›å‚™ç”¨
            
            copyToClipboard(csvOutput);
        }

        /**
         * ğŸ¯ æ–°å¢: è™•ç†å‹¾é¸æ¡†çš„ç‹€æ…‹
         */
        function toggleAllCheckboxes(checked) {
            const checkboxes = document.querySelectorAll('#selectableDateList input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
            });
        }
        
        /**
         * ğŸ¯ æ–°å¢: ç¯©é¸å‹¾é¸çš„æ—¥æœŸä¸¦é€²è¡Œåˆ†é¡ (åŸ DATE_2 æ ¸å¿ƒé‚è¼¯)
         */
        function filterAndClassifyDates() {
            const checkboxes = document.querySelectorAll('#selectableDateList input[type="checkbox"]');
            let filteredRawData = '';
            let successCount = 0;

            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    const csvLine = decodeURIComponent(checkbox.getAttribute('data-csv-line'));
                    filteredRawData += csvLine + '\n';
                    successCount++;
                }
            });

            if (successCount === 0) {
                 document.getElementById('classificationOutput').textContent = "æ²’æœ‰å‹¾é¸ä»»ä½•æ—¥æœŸï¼Œç„¡æ³•é€²è¡Œåˆ†é¡ã€‚";
                 document.getElementById('downloadClassificationButton').disabled = true;
                 return;
            }
            
            // ä»¥ä¸‹æ˜¯åŸ DATE_2 çš„åˆ†é¡é‚è¼¯ï¼Œç¾åœ¨å°ç¯©é¸å¾Œçš„ filteredRawData åŸ·è¡Œ
            
            const dataLines = filteredRawData.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            let classifiedData = {}; 
            let classificationCount = 0;

            dataLines.forEach(line => {
                // CSV è§£æé‚è¼¯éœ€è¦è€ƒæ…®é€—è™Ÿåœ¨é›™å¼•è™Ÿå…§çš„æƒ…æ³ï¼Œä½†æˆ‘å€‘å‡è¨­åŸå§‹è¼¸å…¥æ˜¯ä¹¾æ·¨çš„
                const fields = line.split(',');
                if (fields.length >= 4) {
                    const dateStr = fields[0].trim(); 
                    const subjectWithAmpm = fields[1].trim(); 
                    const description = fields[3].trim().replace(/"/g, ''); // ç§»é™¤é›™å¼•è™Ÿ

                    let ampm = "";
                    let subject = subjectWithAmpm;
                    
                    const ampmMatch = subjectWithAmpm.match(/^(am|pm|am\/pm)-/i);
                    if (ampmMatch) {
                        ampm = ampmMatch[1].toLowerCase();
                        subject = subjectWithAmpm.substring(ampmMatch[0].length); 
                    }
                    
                    const parseResult = parseDateAmpm(dateStr + (ampm ? `,${ampm}` : `,am`)); 
                    
                    if (parseResult.error) {
                         // å¿½ç•¥è§£æéŒ¯èª¤çš„è¡Œ
                        return; 
                    }

                    const dateObj = parseResult.dateObj;
                    
                    if (!classifiedData[description]) {
                        classifiedData[description] = [];
                    }
                    
                    classifiedData[description].push({
                        date: dateObj,
                        timeslot: ampm, 
                        subject: subject, 
                        description: description 
                    });
                    classificationCount++;
                }
            });

            let outputText = `--- æ•´ç†å¾Œçš„è³‡æ–™ (å…± ${classificationCount} ç­†) ---\n`;
            let csvData = "Start date,Subject,All Day Event,Description\n"; 
            
            const sortedDescriptions = Object.keys(classifiedData).sort();

            sortedDescriptions.forEach(descName => {
                outputText += `\nèªªæ˜: ${descName}\n`;
                
                const sortedDates = classifiedData[descName].sort((a, b) => {
                    if (a.date.getTime() !== b.date.getTime()) {
                        return a.date.getTime() - b.date.getTime(); 
                    }
                    return a.date.getHours() - b.date.getHours();
                });

                sortedDates.forEach(data => {
                    const formattedDate = `${data.date.getFullYear()}/${(data.date.getMonth() + 1).toString().padStart(2, '0')}/${data.date.getDate().toString().padStart(2, '0')}`;
                    const formattedTimeslot = data.timeslot ? data.timeslot.toUpperCase() : "";

                    if (formattedTimeslot) {
                        outputText += `${formattedDate} ${formattedTimeslot}- ${data.subject}\n`;
                    } else {
                        outputText += `${formattedDate} ${data.subject}\n`;
                    }
                    
                    const subjectForCsv = formattedTimeslot ? `${formattedTimeslot}-${data.subject}` : data.subject;
                    
                    const safeDate = convertToCsvSafeString(formattedDate);
                    const safeSubject = convertToCsvSafeString(subjectForCsv);
                    const safeAllDayEvent = convertToCsvSafeString("TRUE");
                    const safeDescription = convertToCsvSafeString(data.description);

                    csvData += `${safeDate},${safeSubject},${safeAllDayEvent},${safeDescription}\n`;
                });
            });
            
            document.getElementById('classificationOutput').textContent = outputText;

            if (classificationCount > 0) {
                 lastClassificationCsvData = csvData; 
                 document.getElementById('downloadClassificationButton').disabled = false; 
                 alert(`æ—¥æœŸç¯©é¸èˆ‡åˆ†é¡å·²å®Œæˆï¼ŒæˆåŠŸè™•ç† ${classificationCount} ç­†è³‡æ–™ã€‚`);
            } else {
                 document.getElementById('downloadClassificationButton').disabled = true;
                 alert("æ²’æœ‰è§£æå‡ºæœ‰æ•ˆçš„è³‡æ–™ï¼Œè«‹æª¢æŸ¥å‹¾é¸ç‹€æ…‹ã€‚");
            }
        }
        
        /**
         * åŸ·è¡Œä¸‹è¼‰å‹•ä½œ (ä½¿ç”¨åˆ†é¡å¾Œçš„ CSV å…§å®¹)
         */
        function downloadClassificationCsv() {
            if (lastClassificationCsvData) {
                const filenameDate = getFormattedDateForFilename();
                triggerDownload(lastClassificationCsvData, `${filenameDate}-schedule.csv`);
            } else {
                alert("æ²’æœ‰å¯ä¾›ä¸‹è¼‰çš„åˆ†é¡è³‡æ–™ã€‚è«‹å…ˆåŸ·è¡Œ 'åŸ·è¡Œç¯©é¸èˆ‡åˆ†é¡'ã€‚");
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            generateWeekdayControls(); 
            showSection('dateInputSection');
        });
    </script>
</body>
</html>