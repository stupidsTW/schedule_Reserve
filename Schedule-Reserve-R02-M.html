<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥æœŸè³‡è¨Šè™•ç†å·¥å…· (æ•´åˆè‡ªå‹•è¤‡è£½èˆ‡å‹•æ…‹æª”å)</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; }
        h2 { border-bottom: 2px solid #ccc; padding-bottom: 5px; }
        .function-section { margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .output-area { background-color: #f4f4f4; border: 1px solid #aaa; padding: 10px; margin-top: 10px; white-space: pre-wrap; word-wrap: break-word; min-height: 50px; }
        .debug-area { background-color: #ffe; border: 1px dashed #c90; padding: 10px; margin-top: 10px; white-space: pre-wrap; font-size: 0.9em; max-height: 200px; overflow-y: auto; }
        button { padding: 10px 15px; margin-right: 10px; cursor: pointer; }
        input[type="text"], textarea, input[type="date"], select { width: 98%; padding: 8px; margin-top: 5px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        label { display: block; font-weight: bold; margin-top: 10px; }
        .input-group { margin-bottom: 15px; padding: 10px; border: 1px dotted #ccc; }
        .date-list { margin-top: 10px; padding-left: 20px; }
        .error-message { color: red; font-weight: bold; margin-top: 5px; }
        .range-generator { border: 2px solid #007bff; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        .range-generator h4 { margin-top: 0; color: #007bff; }
        .controls-row { display: flex; justify-content: flex-start; align-items: center; margin-bottom: 15px;}
        .controls-row button { margin-right: 15px; }
        .weekday-controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; padding: 5px 0;}
        .weekday-controls label { font-weight: normal; margin-right: 5px; display: inline-flex; align-items: center;}
        
        /* çªå‡ºé¡¯ç¤ºçš„é€šçŸ¥ */
        #copyStatus {
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            background-color: #e6ffe6; /* æ·ºç¶ è‰²èƒŒæ™¯ */
            color: #007000;
        }

        .classification-section {
            border: 3px solid #ff9800; /* çªå‡ºé¡¯ç¤ºåˆ†é¡å€ */
            padding: 20px;
            margin-top: 30px;
            background-color: #fff9e6;
            border-radius: 5px;
        }

    </style>
</head>
<body>

    <h1>ğŸ“… æ—¥æœŸè³‡è¨Šè™•ç†å·¥å…· (æ•´åˆåŠŸèƒ½)</h1>

    <div class="function-section">
        <h2>ä¸»é¸å–®</h2>
        <button onclick="showSection('dateInputSection')">é–‹å§‹å·¥ä½œ</button>
    </div>

    <div id="dateInputSection" class="function-section">
        <h2>1. è¼¸å…¥èˆ‡å½™æ•´æ—¥æœŸè³‡è¨Š (DATE_1 & DATE_2 æ•´åˆ)</h2>

        <div id="dataItemInput" class="input-group">
            <h3>è¼¸å…¥è³‡æ–™é …ç›®ä¸»é¡Œèˆ‡èªªæ˜</h3>
            <label for="inputSubject">ä¸»é¡Œ:</label>
            <input type="text" id="inputSubject" value="æœƒè­°">

            <label for="inputDescription">èªªæ˜ (ç”¨æ–¼å¾ŒçºŒåˆ†é¡/åˆ†çµ„):</label>
            <input type="text" id="inputDescription" value="å°ˆæ¡ˆAçš„é€²åº¦è¨è«–">
            
            <hr>

            <div class="range-generator">
                <h4>ğŸš€ æ‰¹é‡æ—¥æœŸç”¢ç”Ÿ (Date Range Generator)</h4>
                <label for="startDateRange">é–‹å§‹æ—¥æœŸ (YYYY/MM/DD):</label>
                <input type="text" id="startDateRange" placeholder="ä¾‹å¦‚: 2025/12/01" value="2025/12/01">

                <label for="endDateRange">çµæŸæ—¥æœŸ (YYYY/MM/DD):</label>
                <input type="text" id="endDateRange" placeholder="ä¾‹å¦‚: 2025/12/31" value="2025/12/31">
                
                <label style="margin-top: 15px;">æ’é™¤æ˜ŸæœŸå¹¾:</label>
                <div class="weekday-controls" id="weekdayControls">
                </div>
                
                <label for="excludedDatesManual">æ’é™¤æŒ‡å®šæ—¥æœŸ (YYYY/MM/DDï¼Œé€—è™Ÿåˆ†éš”):</label>
                <input type="text" id="excludedDatesManual" placeholder="ä¾‹å¦‚: 2025/12/25, 2025/12/30">

                <label for="ampmRange">æ™‚æ®µé¸æ“‡ (AM/PM/AM/PM):</label>
                <select id="ampmRange">
                    <option value="am">ä¸Šåˆ (AM)</option>
                    <option value="pm">ä¸‹åˆ (PM)</option>
                    <option value="am/pm">å…¨å¤© (AM/PM)</option>
                </select>

                <button onclick="generateAndAddDates()">ç”¢ç”Ÿä¸¦åŠ å…¥æ—¥æœŸåˆ—è¡¨</button>
                <div id="rangeStatus" class="error-message"></div>
            </div>

            <hr>

            <label for="inputDateAmpm">
                **æˆ–æ‰‹å‹•è¼¸å…¥å¤šè¡Œæ—¥æœŸèˆ‡ä¸Šä¸‹åˆ (æ¯è¡Œä¸€å€‹ YYYY/MM/DD,AM/PM æ ¼å¼)**:
            </label>
            <textarea id="inputDateAmpm" rows="3" placeholder="ä¾‹å¦‚: 
2026/01/05,AM
2026/01/10,PM"></textarea>
            
            <button onclick="addMultipleDates()">æ‰‹å‹•è¼¸å…¥ä¸¦åŠ å…¥æ—¥æœŸ</button>
            
            <div id="dateInputStatus" class="error-message"></div>
            <div id="currentDatesDisplay" class="date-list"></div>
        </div>
        
        <div class="controls-row">
            <button onclick="finishDataItem()">1. å®Œæˆæ­¤è³‡æ–™é …ç›®ä¸¦ç¹¼çºŒ (å„²å­˜)</button>
            <button onclick="processAllDates()">2. é‡æ–°æ•´ç†/å®Œæˆæ‰€æœ‰è³‡æ–™è¼¸å…¥</button>
        </div>
        
        <h3>æ‰€æœ‰è³‡æ–™å½™æ•´è³‡è¨Š (Google Calendar CSV æ ¼å¼)</h3>
        <pre class="output-area" id="csvOutput">è«‹å…ˆå®Œæˆè³‡æ–™é …ç›®å„²å­˜ä»¥é¡¯ç¤ºå½™æ•´çµæœã€‚</pre>
        <p id="copyStatus">CSV å…§å®¹å°‡æœƒè‡ªå‹•è¤‡è£½åˆ°å‰ªè²¼ç°¿ã€‚</p>

        <h3>é™¤éŒ¯è³‡è¨Š (å…¨åŸŸæ’åºå¾Œè³‡æ–™)</h3>
        <div class="debug-area" id="debugOutput"></div>
        
        <div class="classification-section">
            <h3>3. æ—¥æœŸè³‡è¨Šåˆ†é¡èˆ‡é‡çµ„ (DATE_2 æ ¸å¿ƒåŠŸèƒ½)</h3>

            <label for="inputRawData">è«‹è²¼å…¥æ‚¨è¦åˆ†é¡çš„å¤šè¡Œè³‡æ–™ (Google Calendar CSV æ ¼å¼, **å¯ç›´æ¥è²¼ä¸Šä¸Šæ–¹è¤‡è£½çš„å…§å®¹**)ã€‚åœ¨ä¸åƒåŠ çš„æ™‚é–“å‰é¢åŠ å…¥X:</label>
            <textarea id="inputRawData" rows="10" placeholder="ä¾‹å¦‚: 2025/12/15,AM-æœƒè­°,TRUE,å°ˆæ¡ˆAçš„é€²åº¦è¨è«–
2025/12/16,PM-é–‹æœƒ,TRUE,å°ˆæ¡ˆAçš„é€²åº¦è¨è«–
X2025/12/15,AM/PM-ä¼‘æ¯,TRUE,å€‹äººè¡Œç¨‹"></textarea>
            
            <div class="controls-row">
                <button onclick="reclassifyAndGroupData()">é–‹å§‹åˆ†é¡/é‡çµ„</button>
                <button id="downloadClassificationButton" onclick="downloadClassificationCsv()" disabled>
                    â¬‡ï¸ ä¸‹è¼‰åˆ†é¡çµæœ (YYYYMMDD-schedule.csv)
                </button>
            </div>

            <h4>æ•´ç†å¾Œçš„è³‡æ–™ (ä¾èªªæ˜åˆ†çµ„èˆ‡æ—¥æœŸæ’åº)</h4>
            <pre class="output-area" id="classificationOutput"></pre>
        </div>

    </div>

    <script>
        // --- å…¨åŸŸè®Šæ•¸ ---
        let allDataItems = []; 
        let currentItemDates = []; 
        let lastClassificationCsvData = ''; 
        let lastConsolidatedCsvData = ''; // ç”¨æ–¼å„²å­˜ processAllDates ç”¢ç”Ÿçš„æœ€çµ‚ CSV
        
        // JS Date.getDay() å°æ‡‰ï¼š0=æ—¥, 1=ä¸€, 2=äºŒ, 3=ä¸‰, 4=å››, 5=äº”, 6=å…­
        const WEEKDAYS_ZH = ["æ—¥", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­"];

        // --- å·¥å…·å‡½æ•¸ (ä¿æŒä¸è®Š) ---

        function getFormattedDateForFilename() {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            const day = now.getDate().toString().padStart(2, '0');
            return `${year}${month}${day}`;
        }

        function convertToCsvSafeString(inputString) {
            if (inputString === null || inputString === undefined) {
                inputString = "";
            }
            inputString = String(inputString); 
            if (inputString.includes(',') || inputString.includes('"') || inputString.includes('\n')) {
                return `"${inputString.replace(/"/g, '""')}"`;
            }
            return inputString;
        }

        function parseDateAmpm(dateAmpmString) {
            const parts = dateAmpmString.split(',');
            const dateStr = parts[0].trim();
            const ampm = parts.length > 1 ? parts[1].trim().toLowerCase() : 'am';

            if (ampm !== 'am' && ampm !== 'pm' && ampm !== 'am/pm') {
                return { error: `ä¸Šä¸‹åˆè³‡è¨ŠéŒ¯èª¤: ${parts.length > 1 ? parts[1] : ''}ï¼Œè«‹ä½¿ç”¨ AM æˆ– PM æˆ– AM/PM` };
            }

            const dateParts = dateStr.split('/').map(p => parseInt(p, 10));
            if (dateParts.length !== 3 || dateParts.some(isNaN)) {
                 return { error: `æ—¥æœŸæ ¼å¼éŒ¯èª¤: ${dateStr}ï¼Œè«‹ä½¿ç”¨ YYYY/MM/DD` };
            }

            const year = dateParts[0];
            const month = dateParts[1] - 1; 
            const day = dateParts[2];
            
            let hour = 8; 
            const dateObj = new Date(year, month, day, hour, 0, 0);

            if (dateObj.getFullYear() !== year || dateObj.getMonth() !== month || dateObj.getDate() !== day) {
                return { error: `ç„¡æ•ˆçš„æ—¥æœŸ: ${dateStr}` };
            }
            
            if (ampm === 'pm') {
                dateObj.setHours(20); 
                hour = 20;
            } else if (ampm === 'am/pm') {
                dateObj.setHours(8); 
                hour = 8;
            }

            return { dateObj: dateObj, ampm: ampm, hour: hour };
        }

        function parseSimpleDate(dateStr) {
            const dateParts = dateStr.split('/').map(p => parseInt(p, 10));
            if (dateParts.length !== 3 || dateParts.some(isNaN)) {
                return null;
            }
            const year = dateParts[0];
            const month = dateParts[1] - 1; 
            const day = dateParts[2];

            const dateObj = new Date(year, month, day, 0, 0, 0); 
            
            if (dateObj.getFullYear() !== year || dateObj.getMonth() !== month || dateObj.getDate() !== day) {
                return null;
            }
            return dateObj;
        }
        
        function triggerDownload(csvContent, filename) {
            const bom = "\uFEFF"; 
            const blob = new Blob([bom + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
        
        async function copyToClipboard(text) {
            const statusElement = document.getElementById('copyStatus');
            statusElement.textContent = ""; 
            try {
                await navigator.clipboard.writeText(text);
                statusElement.textContent = "âœ… CSV å…§å®¹å·²è‡ªå‹•è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œå¯ç›´æ¥è²¼åˆ°ä¸‹æ–¹çš„ã€Œåˆ†é¡/é‡çµ„ã€å€ã€‚";
                statusElement.style.color = "green";
                statusElement.style.backgroundColor = "#e6ffe6";
                setTimeout(() => {
                    statusElement.textContent = "CSV å…§å®¹å°‡æœƒè‡ªå‹•è¤‡è£½åˆ°å‰ªè²¼ç°¿ã€‚";
                    statusElement.style.color = "#007000"; // æ¢å¾©ç¶ è‰²æ–‡å­—
                    statusElement.style.backgroundColor = "#e6ffe6"; // æ¢å¾©æ·ºç¶ è‰²èƒŒæ™¯
                }, 5000); 
            } catch (err) {
                console.error('ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼ç°¿:', err);
                statusElement.textContent = "âŒ ç„¡æ³•è‡ªå‹•è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œè«‹æ‰‹å‹•è¤‡è£½ä¸Šæ–¹å…§å®¹ã€‚";
                statusElement.style.color = "red";
                statusElement.style.backgroundColor = "transparent";
            }
        }

        // --- ä»‹é¢å’Œé‚è¼¯å‡½æ•¸ ---

        function generateWeekdayControls() {
            const container = document.getElementById('weekdayControls');
            container.innerHTML = ''; 

            WEEKDAYS_ZH.forEach((dayName, index) => {
                const label = document.createElement('label');
                const isWeekend = (index === 0 || index === 6); 
                
                label.innerHTML = `
                    <input type="checkbox" id="excludeDay${index}" data-day-index="${index}" ${isWeekend ? 'checked' : ''}>
                    æ’é™¤é€±${dayName}
                `;
                container.appendChild(label);
            });
        }
        
        function showSection(sectionId) {
            // ç”±æ–¼åªå‰©ä¸€å€‹å€å¡Šï¼Œç°¡åŒ– showSection é‚è¼¯
            document.getElementById('dateInputSection').style.display = 'block';

            if (sectionId === 'dateInputSection') {
                currentItemDates = [];
                updateCurrentDatesDisplay();
                
                if (allDataItems.length === 0) {
                     document.getElementById('inputSubject').value = 'æœƒè­°';
                     document.getElementById('inputDescription').value = 'å°ˆæ¡ˆAçš„é€²åº¦è¨è«–';
                }
                
                document.getElementById('inputDateAmpm').value = '';
                document.getElementById('dateInputStatus').textContent = '';
                document.getElementById('rangeStatus').textContent = '';
                processAllDates(); 
                generateWeekdayControls(); 
            }
            // æ¸…ç©ºåˆ†é¡çµæœï¼Œé¿å…èˆ‡ DATE_1 è¼¸å‡ºæ··æ·†
            document.getElementById('classificationOutput').textContent = '';
            document.getElementById('downloadClassificationButton').disabled = true;
            lastClassificationCsvData = ''; 
        }

        function updateCurrentDatesDisplay() {
            const container = document.getElementById('currentDatesDisplay');
            container.innerHTML = '<h4>âœ… å·²åŠ å…¥çš„æ—¥æœŸ (æ­¤è³‡æ–™é …ç›®):</h4>';
            if (currentItemDates.length === 0) {
                container.innerHTML += '<p>ç„¡æ—¥æœŸè³‡è¨Š</p>';
                return;
            }

            const ul = document.createElement('ul');
            const sortedDates = [...currentItemDates].sort((a, b) => a.dateObj.getTime() - b.dateObj.getTime());

            sortedDates.forEach(item => {
                const li = document.createElement('li');
                const ampmText = item.ampm.toUpperCase();
                const dateStr = `${item.dateObj.getFullYear()}/${(item.dateObj.getMonth() + 1).toString().padStart(2, '0')}/${item.dateObj.getDate().toString().padStart(2, '0')}`;
                const timeStr = item.dateObj.toTimeString().substring(0, 5); 
                const dayIndex = item.dateObj.getDay(); 
                li.textContent = `${dateStr} (é€±${WEEKDAYS_ZH[dayIndex]}), ${ampmText} (${timeStr}) - ${item.subject}`;
                ul.appendChild(li);
            });
            container.appendChild(ul);
        }

        function generateAndAddDates() {
             // ... (ä¿æŒåŸæœ‰çš„ generateAndAddDates é‚è¼¯)
            const startStr = document.getElementById('startDateRange').value.trim();
            const endStr = document.getElementById('endDateRange').value.trim();
            const excludedManualStr = document.getElementById('excludedDatesManual').value.trim();
            const ampmRange = document.getElementById('ampmRange').value;
            const statusElement = document.getElementById('rangeStatus');
            const subject = document.getElementById('inputSubject').value.trim();
            const description = document.getElementById('inputDescription').value.trim();
            statusElement.textContent = '';
            
            if (!subject || !description) {
                statusElement.textContent = "è«‹å…ˆè¼¸å…¥ä¸»é¡Œå’Œèªªæ˜ã€‚";
                return;
            }

            const startDate = parseSimpleDate(startStr);
            const endDate = parseSimpleDate(endStr);

            if (!startDate || !endDate) {
                statusElement.textContent = "é–‹å§‹æ—¥æœŸæˆ–çµæŸæ—¥æœŸæ ¼å¼éŒ¯èª¤ (éœ€ç‚º YYYY/MM/DD)ã€‚";
                return;
            }
            if (startDate > endDate) {
                statusElement.textContent = "é–‹å§‹æ—¥æœŸå¿…é ˆæ—©æ–¼æˆ–ç­‰æ–¼çµæŸæ—¥æœŸã€‚";
                return;
            }

            const excludedDays = new Set();
            for(let i = 0; i < 7; i++) {
                const checkbox = document.getElementById(`excludeDay${i}`);
                if (checkbox && checkbox.checked) {
                    excludedDays.add(i);
                }
            }

            const excludedDatesSet = new Set();
            if (excludedManualStr) {
                const manualDates = excludedManualStr.split(',').map(d => d.trim()).filter(d => d.length > 0);
                manualDates.forEach(dateStr => {
                    const dateObj = parseSimpleDate(dateStr);
                    if (dateObj) {
                        excludedDatesSet.add(dateObj.toISOString().substring(0, 10)); 
                    } else {
                        statusElement.textContent += `æ’é™¤æ—¥æœŸæ ¼å¼éŒ¯èª¤: ${dateStr} å·²å¿½ç•¥ã€‚\n`;
                    }
                });
            }

            let currentDate = new Date(startDate);
            let successCount = 0;

            while (currentDate <= endDate) {
                const currentISODate = currentDate.toISOString().substring(0, 10);
                const dayOfWeek = currentDate.getDay(); 
                let isExcluded = false;

                if (excludedDays.has(dayOfWeek)) {
                    isExcluded = true;
                }
                
                if (excludedDatesSet.has(currentISODate)) {
                    isExcluded = true;
                }

                if (!isExcluded) {
                    const dateStrForParse = `${currentDate.getFullYear()}/${currentDate.getMonth() + 1}/${currentDate.getDate()},${ampmRange}`;
                    const result = parseDateAmpm(dateStrForParse);

                    if (!result.error) {
                        const dateInfo = {
                            dateObj: result.dateObj,
                            ampm: ampmRange,
                            timeslotHour: result.hour,
                            subject: subject,
                            description: description
                        };
                        // æª¢æŸ¥é‡è¤‡ (åŒä¸€å¤©åŒä¸€ ampm æ™‚æ®µæ˜¯å¦æœ‰é‡è¤‡)
                        const isDuplicate = currentItemDates.some(
                            item => item.dateObj.toISOString().substring(0, 10) === dateInfo.dateObj.toISOString().substring(0, 10) && item.ampm === dateInfo.ampm
                        );

                        if (!isDuplicate) {
                             currentItemDates.push(dateInfo);
                             successCount++;
                        }
                    }
                }

                currentDate.setDate(currentDate.getDate() + 1);
            }

            updateCurrentDatesDisplay();
            statusElement.textContent = `æˆåŠŸç”¢ç”Ÿä¸¦åŠ å…¥äº† ${successCount} å€‹ç¬¦åˆæ¢ä»¶çš„æ—¥æœŸã€‚`;
        }

        function addMultipleDates() {
            // ... (ä¿æŒåŸæœ‰çš„ addMultipleDates é‚è¼¯)
            const input = document.getElementById('inputDateAmpm').value;
            const subject = document.getElementById('inputSubject').value.trim();
            const description = document.getElementById('inputDescription').value.trim();
            const statusElement = document.getElementById('dateInputStatus');
            statusElement.textContent = ''; 

            if (!subject || !description) {
                statusElement.textContent = "è«‹å…ˆè¼¸å…¥ä¸»é¡Œå’Œèªªæ˜ã€‚";
                return;
            }
            if (!input.trim()) {
                statusElement.textContent = "æ—¥æœŸè¼¸å…¥æ¡†ä¸å¯ç‚ºç©ºã€‚";
                return;
            }

            const inputLines = input.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let successCount = 0;
            let errorMessages = [];

            inputLines.forEach((line, index) => {
                const normalizedLine = line.includes(',') ? line : `${line},am`; 
                const result = parseDateAmpm(normalizedLine);

                if (result.error) {
                    errorMessages.push(`ç¬¬ ${index + 1} è¡Œ (${line}): ${result.error}`);
                    return; 
                }

                const dateInfo = {
                    dateObj: result.dateObj,
                    ampm: result.ampm,
                    timeslotHour: result.hour,
                    subject: subject,
                    description: description
                };
                
                // æª¢æŸ¥é‡è¤‡
                const isDuplicate = currentItemDates.some(
                    item => item.dateObj.toISOString().substring(0, 10) === dateInfo.dateObj.toISOString().substring(0, 10) && item.ampm === dateInfo.ampm
                );
                
                if (!isDuplicate) {
                    currentItemDates.push(dateInfo);
                    successCount++;
                } else {
                    errorMessages.push(`ç¬¬ ${index + 1} è¡Œ (${line}): èˆ‡ç¾æœ‰åˆ—è¡¨é‡è¤‡ï¼Œå·²å¿½ç•¥ã€‚`);
                }
            });

            updateCurrentDatesDisplay();
            
            if (errorMessages.length > 0) {
                statusElement.textContent = `æˆåŠŸåŠ å…¥ ${successCount} å€‹æ—¥æœŸã€‚ä»¥ä¸‹æ˜¯éŒ¯èª¤/å¿½ç•¥åˆ—è¡¨:\n${errorMessages.join('\n')}`;
            } else if (successCount > 0) {
                statusElement.textContent = `æˆåŠŸåŠ å…¥æ‰€æœ‰ ${successCount} å€‹æ—¥æœŸã€‚`;
            } else {
                 statusElement.textContent = `æ²’æœ‰æˆåŠŸçš„æ—¥æœŸè¼¸å…¥ã€‚`;
            }
            document.getElementById('inputDateAmpm').value = ''; 
        }
        
        /**
         * å®Œæˆç•¶å‰è³‡æ–™é …ç›®ï¼Œå„²å­˜åˆ° allDataItemsï¼Œä¸¦ç«‹å³æ›´æ–° CSV å½™æ•´çµæœã€‚
         */
        function finishDataItem() {
            const subject = document.getElementById('inputSubject').value.trim();
            const description = document.getElementById('inputDescription').value.trim();

            if (!subject || !description) {
                alert("ä¸»é¡Œæˆ–èªªæ˜ä¸å¯ç‚ºç©ºã€‚");
                return;
            }
            
            if (currentItemDates.length === 0) {
                 alert("è«‹å…ˆåŠ å…¥è‡³å°‘ä¸€å€‹æ—¥æœŸï¼Œå†å„²å­˜æ­¤è³‡æ–™é …ç›®ã€‚");
                 return;
            }


            // 1. å„²å­˜ç•¶å‰çš„è³‡æ–™é …ç›®
            allDataItems.push({
                subject: subject,
                description: description,
                dateInfo: [...currentItemDates] 
            });

            // 2. æ¸…ç†ç•¶å‰è¼¸å…¥å€åŸŸï¼Œæº–å‚™è¼¸å…¥ä¸‹ä¸€å€‹é …ç›®
            currentItemDates = [];
            // ä¿ç•™ä¸»é¡Œå’Œèªªæ˜
            // document.getElementById('inputSubject').value = ''; 
            // document.getElementById('inputDescription').value = '';
            document.getElementById('inputDateAmpm').value = '';
            updateCurrentDatesDisplay(); 
            document.getElementById('dateInputStatus').textContent = '';
            document.getElementById('rangeStatus').textContent = '';
            
            // 3. ç«‹å³å‘¼å« processAllDates() ä¾†æ›´æ–°å’Œé¡¯ç¤ºæ‰€æœ‰çš„å½™æ•´è³‡æ–™
            processAllDates(); 
            
            alert(`è³‡æ–™é …ç›®å·²å„²å­˜ (ç›®å‰å…±æœ‰ ${allDataItems.length} å€‹é …ç›®)ã€‚æ‰€æœ‰è³‡æ–™å½™æ•´è³‡è¨Šå·²æ›´æ–°ã€‚`);
        }

        /**
         * è™•ç†æ‰€æœ‰å·²å„²å­˜çš„æ—¥æœŸï¼Œç”Ÿæˆ CSVï¼Œä¸¦è‡ªå‹•è¤‡è£½ã€‚
         */
        function processAllDates() {
            
            if (allDataItems.length === 0) {
                document.getElementById('csvOutput').textContent = "æ²’æœ‰ä»»ä½•å·²å„²å­˜çš„è³‡æ–™é …ç›®ã€‚";
                document.getElementById('debugOutput').textContent = "æ²’æœ‰ä»»ä½•å·²å„²å­˜çš„è³‡æ–™é …ç›®ã€‚";
                lastConsolidatedCsvData = '';
                copyToClipboard(""); 
                return;
            }

            let globalDateInfoArray = [];
            allDataItems.forEach(dataItem => {
                globalDateInfoArray.push(...dataItem.dateInfo);
            });

            const sortedGlobalDateInfoArray = globalDateInfoArray.sort((a, b) => {
                return a.dateObj.getTime() - b.dateObj.getTime();
            });

            let debugOutput = "--- é™¤éŒ¯è³‡è¨Šï¼šå…¨åŸŸæ’åºå¾Œè³‡æ–™ ---\n";
            sortedGlobalDateInfoArray.forEach(info => {
                 const dateStr = info.dateObj.toISOString().substring(0, 10);
                 debugOutput += `  æ—¥æœŸç‰©ä»¶: ${dateStr} ${info.dateObj.toTimeString().substring(0, 8)}, ä¸Šä¸‹åˆ: ${info.ampm}, ä¸»é¡Œ: ${info.subject}, èªªæ˜: ${info.description}\n`;
            });
            document.getElementById('debugOutput').textContent = debugOutput;

            // ç”Ÿæˆ Google Calendar CSV æ ¼å¼
            let csvOutput = "Start date,Subject,All Day Event,Description\n";
            sortedGlobalDateInfoArray.forEach(info => {
                const dateString = `${info.dateObj.getFullYear()}/${(info.dateObj.getMonth() + 1).toString().padStart(2, '0')}/${info.dateObj.getDate().toString().padStart(2, '0')}`;
                
                const subjectForCsv = info.ampm.toUpperCase() ? `${info.ampm.toUpperCase()}-${info.subject}` : info.subject;

                const safeDate = convertToCsvSafeString(dateString);
                const safeSubject = convertToCsvSafeString(subjectForCsv);
                const safeAllDayEvent = convertToCsvSafeString("TRUE");
                const safeDescription = convertToCsvSafeString(info.description);

                csvOutput += `${safeDate},${safeSubject},${safeAllDayEvent},${safeDescription}\n`;
            });

            document.getElementById('csvOutput').textContent = csvOutput;
            lastConsolidatedCsvData = csvOutput;
            
            // åŸ·è¡Œè¤‡è£½åˆ°å‰ªè²¼ç°¿
            copyToClipboard(csvOutput);
            
            // å°‡è¼¸å‡ºçµæœè‡ªå‹•å¡«å…¥ä¸‹æ–¹çš„åˆ†é¡/é‡çµ„å€å¡Š
            document.getElementById('inputRawData').value = csvOutput;
        }
        
        /**
         * èª¿æ•´ DATE_2 æ ¸å¿ƒåŠŸèƒ½ï¼Œå‘½åç‚º reclassifyAndGroupData
         */
        function reclassifyAndGroupData() {
            const rawDataString = document.getElementById('inputRawData').value.trim();
            const outputElement = document.getElementById('classificationOutput');
            const downloadButton = document.getElementById('downloadClassificationButton');
            
            outputElement.textContent = ''; 
            downloadButton.disabled = true; 
            lastClassificationCsvData = ''; 

            if (!rawDataString) {
                outputElement.textContent = "è«‹è²¼å…¥è¦åˆ†é¡çš„è³‡æ–™ã€‚";
                return;
            }
            
            // å¿½ç•¥æ¨™é ­è¡Œ
            const dataLines = rawDataString.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0 && !line.startsWith('Start date,') && !line.toUpperCase().startsWith('X'));
            
            let classifiedData = {}; 
            let successCount = 0;

            dataLines.forEach(line => {
                const fields = line.split(',');
                // å¿…é ˆæœ‰ Start date, Subject, All Day Event, Description é€™å››å€‹æ¬„ä½ (æˆ–æ›´å¤š)
                if (fields.length >= 4) {
                    const dateStr = fields[0].trim().replace(/"/g, ''); 
                    const subjectWithAmpm = fields[1].trim().replace(/"/g, ''); 
                    const description = fields[3].trim().replace(/"/g, ''); 

                    let ampm = "";
                    let subject = subjectWithAmpm;
                    
                    const ampmMatch = subjectWithAmpm.match(/^(am|pm|am\/pm)-/i);
                    if (ampmMatch) {
                        ampm = ampmMatch[1].toLowerCase();
                        subject = subjectWithAmpm.substring(ampmMatch[0].length); 
                    }
                    
                    // ä¿®æ­£ï¼šparseDateAmpm åªéœ€è¦ YYYY/MM/DD,AM/PM æ ¼å¼
                    const parseResult = parseDateAmpm(dateStr + (ampm ? `,${ampm}` : `,am`)); 
                    
                    if (parseResult.error) {
                         // å¿½ç•¥è§£æéŒ¯èª¤çš„è¡Œ
                        return; 
                    }

                    const dateObj = parseResult.dateObj;
                    
                    if (!classifiedData[description]) {
                        classifiedData[description] = [];
                    }
                    
                    classifiedData[description].push({
                        date: dateObj,
                        timeslot: ampm, 
                        subject: subject, 
                        description: description 
                    });
                    successCount++;
                }
            });

            let outputText = `--- æ•´ç†å¾Œçš„è³‡æ–™ (å…± ${successCount} ç­†) ---\n`;
            let csvData = "Start date,Subject,All Day Event,Description\n"; 
            
            const sortedDescriptions = Object.keys(classifiedData).sort();

            sortedDescriptions.forEach(descName => {
                outputText += `\n**èªªæ˜: ${descName}**\n`;
                
                const sortedDates = classifiedData[descName].sort((a, b) => {
                    // å…ˆæŒ‰æ—¥æœŸæ’åº
                    if (a.date.getTime() !== b.date.getTime()) {
                        return a.date.getTime() - b.date.getTime(); 
                    }
                    // å†æŒ‰æ™‚æ®µ/å°æ™‚æ’åº (ç¢ºä¿ AM åœ¨ PM å‰)
                    return a.date.getHours() - b.date.getHours();
                });

                sortedDates.forEach(data => {
                    const formattedDate = `${data.date.getFullYear()}/${(data.date.getMonth() + 1).toString().padStart(2, '0')}/${data.date.getDate().toString().padStart(2, '0')}`;
                    const dayIndex = data.date.getDay(); 
                    const formattedTimeslot = data.timeslot ? data.timeslot.toUpperCase() : "";

                    let outputLine = `${formattedDate} (é€±${WEEKDAYS_ZH[dayIndex]})`;
                    if (formattedTimeslot) {
                         outputLine += ` ${formattedTimeslot}- ${data.subject}`;
                    } else {
                        outputLine += ` ${data.subject}`;
                    }
                    outputText += outputLine + "\n";
                    
                    const subjectForCsv = formattedTimeslot ? `${formattedTimeslot}-${data.subject}` : data.subject;
                    
                    const safeDate = convertToCsvSafeString(formattedDate);
                    const safeSubject = convertToCsvSafeString(subjectForCsv);
                    const safeAllDayEvent = convertToCsvSafeString("TRUE");
                    const safeDescription = convertToCsvSafeString(data.description);

                    csvData += `${safeDate},${safeSubject},${safeAllDayEvent},${safeDescription}\n`;
                });
            });
            
            outputElement.textContent = outputText;

            if (successCount > 0) {
                 lastClassificationCsvData = csvData; 
                 downloadButton.disabled = false; 
                 alert("æ—¥æœŸè³‡è¨Šåˆ†é¡/é‡çµ„å·²å®Œæˆï¼Œè«‹æŸ¥çœ‹çµæœä¸¦ä¸‹è¼‰ Google Calendar æ ¼å¼çš„ CSVã€‚");
            } else {
                 downloadButton.disabled = true;
                 alert("æ²’æœ‰è§£æå‡ºæœ‰æ•ˆçš„è³‡æ–™ã€‚è«‹ç¢ºèªè³‡æ–™æ ¼å¼æˆ–æ˜¯å¦éƒ½å·²è¢« 'X' æ’é™¤ã€‚");
            }
        }
        
        function downloadClassificationCsv() {
            if (lastClassificationCsvData) {
                const filenameDate = getFormattedDateForFilename();
                triggerDownload(lastClassificationCsvData, `${filenameDate}-schedule.csv`);
            } else {
                alert("æ²’æœ‰å¯ä¾›ä¸‹è¼‰çš„åˆ†é¡è³‡æ–™ã€‚è«‹å…ˆåŸ·è¡Œ 'é–‹å§‹åˆ†é¡/é‡çµ„'ã€‚");
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            generateWeekdayControls(); 
            showSection('dateInputSection');
        });
    </script>
</body>
</html>